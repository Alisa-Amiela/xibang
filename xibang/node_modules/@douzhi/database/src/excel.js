const XLSX = require("xlsx");

class Excel {
  constructor(filePath) {
    this.fields = [];
    this.filePath = filePath + ".xlsx";
    this.workbook = XLSX.readFile(this.filePath);
    this.worksheet = this.workbook.Sheets[this.workbook.SheetNames[0]];
    this.records = XLSX.utils.sheet_to_json(this.worksheet);
    if (this.workbook.SheetNames.length > 1) {
      let delSheetNames = this.workbook.SheetNames.filter((value, index) => {
        return index !== 0;
      });
      this.removeSheet(delSheetNames);
    }
  }

  findAll(options) {
    if (options === undefined) return this.records || [];
    let records = this.records;
    if (options.where !== undefined) {
      records = this.records.filter(element => {
        let count = 0;
        for (let key in options.where) {
          element[key] == options.where[key] && ++count;
        }
        return Object.keys(options.where).length === count;
      });
    }
    if (options.orderBy !== undefined) {
      for (let key in options.orderBy) {
        records.sort((a, b) => {
          if (a[key] > b[key]) {
            return options.orderBy[key] == "desc" ? -1 : 1;
          } else if (a[key] < b[key]) {
            return options.orderBy[key] == "desc" ? 1 : -1;
          } else {
            return 0;
          }
        });
      }
    }
    return records;
  }

  findOne(options = {}) {
    return this.findAll(options)[0];
  }

  findByPk(value) {
    let pk = this.getPk();
    let where = {};
    where[pk] = value;
    return (
      this.findOne({
        where: where
      }) || []
    );
  }

  create(data) {
    let record = {};
    let startCount = this.records.length;
    this.getFields().forEach((element, key) => {
      record[element] = data[element] !== undefined ? data[element] : "";
    });
    record[this.getPk()] = this.getIncrement();
    this.records.push(record);
    XLSX.utils.sheet_add_json(this.worksheet, this.records);
    XLSX.writeFileSync(this.workbook, this.filePath);
    let endCount = this.count();
    if (endCount > startCount) {
      return record;
    } else {
      return {};
    }
  }

  update(data, options) {
    let before;
    let after;
    if (options.where != undefined) {
      this.records.forEach(element => {
        let count = 0;
        for (let key in options.where) {
          if (options.where[key] == element[key]) {
            ++count;
          }
        }
        if (count === Object.keys(options.where).length) {
          before = Object.assign({}, element);
          for (let k in data) {
            element[k] = data[k];
          }
          after = Object.assign({}, element);
        }
      });
      XLSX.utils.sheet_add_json(this.worksheet, this.records);
      XLSX.writeFileSync(this.workbook, this.filePath);
    }
    return JSON.stringify(before) != JSON.stringify(after) ? after : {};
  }

  count() {
    let workbook = XLSX.readFile(this.filePath);
    let worksheet = workbook.Sheets[workbook.SheetNames[0]];
    let records = XLSX.utils.sheet_to_json(worksheet);
    return records.length;
  }

  delete(options = {}) {
    if (options === {}) return false;
    this.empty();
    if (options.where !== undefined) {
      let length = Object.keys(options.where).length;
      this.records.forEach((element, key) => {
        let count = 0;
        if (options.where !== undefined) {
          for (let key in options.where) {
            element[key] == options.where[key] && ++count;
          }
          if (length === count) {
            this.records.splice(key, 1);
          }
        }
      });
    }
    XLSX.utils.sheet_add_json(this.workbook.Sheets["Sheet1"], this.records);
    XLSX.writeFileSync(this.workbook, this.filePath);
  }

  empty() {
    let ws = XLSX.utils.aoa_to_sheet([this.getFields()]);
    delete this.workbook.Sheets["Sheet1"];
    this.workbook.SheetNames.splice(0, 1);
    XLSX.utils.book_append_sheet(this.workbook, ws, "Sheet1");
    XLSX.writeFileSync(this.workbook, this.filePath);
  }

  removeSheet(sheetName) {
    sheetName.forEach(() => {
      delete this.workbook.Sheets[sheetName];
      this.workbook.SheetNames.splice(
        this.workbook.SheetNames.findIndex(value => value === sheetName),
        1
      );
    });
    XLSX.writeFileSync(this.workbook, this.filePath);
  }

  getPk() {
    return this.getFields[0] || "id";
  }

  getFields() {
    let words = "ABCDEFGHIJKLMNOPQRSTUVWSYZ";
    for (let k in words) {
      let key = words[k] + "1";
      if (this.worksheet[key] != undefined) {
        this.fields.push(this.worksheet[key].v);
      }
    }
    return this.fields;
  }

  getIncrement() {
    let max = 0;
    this.records.forEach(element => {
      if (element[this.getPk()] > max) {
        max = element[this.getPk()];
      }
    });
    return ++max;
  }
}

module.exports = function(filePath) {
  return new Excel(filePath);
};
