const fs = require("fs");

class Json {
  constructor(filePath) {
    this.filePath = filePath;
    this.items = JSON.parse(fs.readFileSync(this.filePath, "utf-8"));
  }

  findAll(options = {}) {
    if (options === {}) return this.items;
    let items = this.items.filter(element => {
      let count = 0;
      if (options.where !== undefined) {
        for (let key in options.where) {
          element[key] == options.where[key] && ++count;
        }
        return Object.keys(options.where).length === count;
      }
    });
    return items;
  }

  findByPk(value) {
    return this.items.filter(item => item[this.getPk()] == value)[0];
  }

  save(data, options = {}) {
    if (data === undefined) return;
    let item = {};
    if (options === {}) {
      data[this.getPk()] = this.getIncrement();
      this.getFields().forEach((element, key) => {
        item[element] = data[element] !== undefined ? data[element] : "";
      });
      this.items.push(item);
    } else {
      this.getFields().forEach((element, key) => {
        item[element] = data[element] !== undefined ? data[element] : "";
      });
      let index = this.items.findIndex(
        element => element.id == options.where.id
      );
      Object.assign(this.items[index], data);
    }
    fs.writeFileSync(this.filePath, JSON.stringify(this.items, null, 2));
  }

  getPk() {
    if (this.items.length > 0) {
      for (let key in this.items[0]) return key;
    } else {
      return "id";
    }
  }

  getFields() {
    let fields = [];
    if (this.items.length > 0) {
      fields = Object.keys(this.items[0]);
    }
    return fields;
  }

  getIncrement() {
    let max = 0;
    this.items.forEach(element => {
      if (element[this.getPk()] > max) {
        max = element[this.getPk()];
      }
    });
    return ++max;
  }

  delete(options) {
    let items = this.items.filter(element => element.id != options.where.id);
    fs.writeFileSync(this.filePath, JSON.stringify(items, null, 2));
  }
}

module.exports = Json;
